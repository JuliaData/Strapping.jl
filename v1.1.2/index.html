<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Strapping.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Strapping.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>Home</a><ul class="internal"><li><a class="toctext" href="#Strapping.construct-1"><code>Strapping.construct</code></a></li><li><a class="toctext" href="#Strapping.deconstruct-1"><code>Strapping.deconstruct</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaData/Strapping.jl/blob/master/docs/src/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Strapping.jl-1" href="#Strapping.jl-1">Strapping.jl</a></h1><p>This guide provides documentation around the <code>Strapping.construct</code> and <code>Strapping.deconstruct</code> functions. This package was born from a desire for straightforward, not-too-magical ORM capabilities in Julia, which means being able to transform, for example, 2D SQL query results from a database into a <code>Vector</code> of custom application objects, without having to write your own adapter code. Strapping.jl integrates with the <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> package, which allows customizing Julia structs and their fields.</p><p>If anything isn&#39;t clear or you find bugs, don&#39;t hesitate to <a href="https://github.com/JuliaData/Strapping.jl/issues/new">open a new issue</a>, even just for a question, or come chat with us on the <a href="https://julialang.slack.com/messages/data/">#data</a> slack channel with questions, concerns, or clarifications.</p><ul><li><a href="#Strapping.jl-1">Strapping.jl</a></li><ul><li><a href="#Strapping.construct-1"><code>Strapping.construct</code></a></li><li><a href="#Strapping.deconstruct-1"><code>Strapping.deconstruct</code></a></li></ul></ul><h2><a class="nav-anchor" id="Strapping.construct-1" href="#Strapping.construct-1"><code>Strapping.construct</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Strapping.construct" href="#Strapping.construct"><code>Strapping.construct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Strapping.construct(T, tbl)
Strapping.construct(Vector{T}, tbl)</code></pre><p>Given a <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a>-compatible input table source <code>tbl</code>, construct an instance of <code>T</code> (single object, first method), or <code>Vector{T}</code> (list of objects, 2nd method).</p><p>The 1st method will throw an error if the input table is empty, and warn if there are more rows than necessary to construct a single <code>T</code>.</p><p>The 2nd method will return an empty list for an empty input source, and construct as many <code>T</code> as are found until the input table is exhausted.</p><p><code>Strapping.construct</code> utilizes the <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> package for determining the <code>StructTypes.StructType</code> trait of <code>T</code> and constructing an instance appropriately:     * <code>StructTypes.Struct</code>/<code>StructTypes.Mutable</code>: field reflection will be used to retrieve values from the input table row, with field customizations respected, like excluded fields, field-specific keyword args, etc.     * <code>StructTypes.DictType</code>: each column name/value of the table row will be used as a key/value pair to be passed to the <code>DictType</code> constructor     * <code>StructTypes.ArrayType</code>: column values will be &quot;collected&quot; as an array to be passed to the <code>ArrayType</code> constructor     * <code>StructTypes.StringType</code>/<code>StructTypes.NumberType</code>/<code>StructTypes.BoolType</code>/<code>StructTypes.NullType</code>: only the first value of the row will be passed to the scalar type constructor</p><p>Note that for <code>StructTypes.DictType</code> and <code>StructTypes.ArrayType</code>, &quot;aggregate&quot; value/eltypes are not allowed, since the entire row is treated as key/value pairs or array elements. That means, for example, I can&#39;t have a table with rows like <code>tbl = [(a=1, b=2)]</code> and try to do <code>Strapping.construct(Dict{Symbol, Dict{Int, Int}}, tbl)</code>. It first attempts to map column names to the outer <code>Dict</code> keys, (<code>a</code> and <code>b</code>), but then tries to map the values <code>1</code> and <code>2</code> to <code>Dict{Int, Int}</code> and fails.</p><p>For structs with <code>ArrayType</code> fields, the first row values will be used for other scalar fields, and subsequent rows will be iterated for the <code>ArrayType</code> field values. For example, I may wish to construct a type like:</p><pre><code class="language-julia">struct TestResult
    id::Int
    values::Vector{Float64}
end
StructTypes.StructType(::Type{TestResult}) = StructTypes.Struct()
StructTypes.idproperty(::Type{TestResult}) = :id</code></pre><p>and my input table would look something like, <code>tbl = (id=[1, 1, 1], values=[3.14, 3.15, 3.16])</code>. I can then construct my type like:</p><pre><code class="language-julia">julia&gt; Strapping.construct(TestResult, tbl)
TestResult(1, [3.14, 3.15, 3.16])</code></pre><p>Note that along with defining the <code>StructTypes.StructType</code> trait for <code>TestResult</code>, I also needed to define <code>StructTypes.idproperty</code> to signal which field of my struct is a &quot;unique key&quot; identifier. This enables Strapping to distinguish which rows belong to a particular instance of <code>TestResult</code>. This allows the slightly more complicated example of returning multiple <code>TestResult</code>s from a single table:</p><pre><code class="language-julia">julia&gt; tbl = (id=[1, 1, 1, 2, 2, 2], values=[3.14, 3.15, 3.16, 40.1, 0.01, 2.34])
(id = [1, 1, 1, 2, 2, 2], values = [3.14, 3.15, 3.16, 40.1, 0.01, 2.34])

julia&gt; Strapping.construct(Vector{TestResult}, tbl)
2-element Array{TestResult,1}:
 TestResult(1, [3.14, 3.15, 3.16])
 TestResult(2, [40.1, 0.01, 2.34])</code></pre><p>Here, we actually have <em>two</em> <code>TestResult</code> objects in our <code>tbl</code>, and Strapping uses the <code>id</code> field to identify object owners for a row. Note that currently the table rows need to be sorted on the <code>idproperty</code> field, i.e. rows belonging to the same object must appear consecutively in the input table rows.</p><p>Now let&#39;s discuss &quot;aggregate&quot; type fields. Let&#39;s say I have a struct like:</p><pre><code class="language-julia">struct Experiment
    id::Int
    name::String
    testresults::TestResult
end
StructTypes.StructType(::Type{Experiment}) = StructTypes.Struct()
StructTypes.idproperty(::Type{Experiment}) = :id</code></pre><p>So my <code>Experiment</code> type also as an <code>id</code> field, in addition to a <code>name</code> field, and an &quot;aggregate&quot; field of <code>testresults</code>. How should the input table source account for <code>testresults</code>, which is itself a struct made up of its own <code>id</code> and <code>values</code> fields? The key here is &quot;flattening&quot; nested structs into a single set of table column names, and utilizing the <code>StructTypes.fieldprefix</code> function, which allows specifying a <code>Symbol</code> prefix to identify an aggregate field&#39;s columns in the table row. So, in the case of our <code>Experiment</code>, we can do:</p><pre><code class="language-julia">StructTypes.fieldprefix(::Type{Experiment}, nm::Symbol) = nm == :testresults ? :testresults_ : :_</code></pre><p>Note that this is the default definition, so we don&#39;t really need to define this, but for illustration purposes, we&#39;ll walk through it. We&#39;re saying that for the <code>:testresults</code> field name, we should expect its column names in the table row to start with <code>:testresults_</code>. So the table data for an <code>Experiment</code> instance, would look something like:</p><pre><code class="language-julia">tbl = (id=[1, 1, 1], name=[&quot;exp1&quot;, &quot;exp1&quot;, &quot;exp1&quot;], testresults_id=[1, 1, 1], testresults_values=[3.14, 3.15, 3.16])</code></pre><p>This pattern generalizes to structs with multiple aggregate fields, or aggregate fields that themselves have aggregate fields (nested aggregates); in the nested case, the prefixes are concatenated, like <code>testresults_specifictestresult_id</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/Strapping.jl/blob/366e90c19c03ea94e18db03b4e8ddd9bff8fb296/src/Strapping.jl#LL9-L90">source</a></section><h2><a class="nav-anchor" id="Strapping.deconstruct-1" href="#Strapping.deconstruct-1"><code>Strapping.deconstruct</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Strapping.deconstruct" href="#Strapping.deconstruct"><code>Strapping.deconstruct</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Strapping.deconstruct(x::T)
Strapping.deconstruct(x::Vector{T})</code></pre><p>The inverse of <code>Strapping.construct</code>, where an object instance <code>x::T</code> or <code>Vector</code> of objects <code>x::Vector{T}</code> is &quot;deconstructed&quot; into a Tables.jl-compatible row iterator. This works following the same patterns outlined in <code>Strapping.construct</code> with regards to <code>ArrayType</code> and aggregate fields. Specifically, <code>ArrayType</code> fields will cause multiple rows to be outputted, one row per collection element, with other scalar fields being repeated in each row. Similarly for aggregate fields, the field prefix will be used (<code>StructTypes.fieldprefix</code>) and nested aggregates will all be flattened into a single list of column names with aggregate prefixes.</p><p>In general, this allows outputting any &quot;object&quot; as a 2D table structure that could be stored in any Tables.jl-compatible sink format, e.g. csv file, sqlite table, mysql database table, feather file, etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaData/Strapping.jl/blob/366e90c19c03ea94e18db03b4e8ddd9bff8fb296/src/Strapping.jl#LL339-L346">source</a></section><footer><hr/></footer></article></body></html>
